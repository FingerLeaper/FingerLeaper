<!doctype html>
<html lang=en>
<head>
<title>LeapReplay</title>
<meta charset=utf-8>
</head>
<body>
<script src=http://js.leapmotion.com/0.2.1/leap.min.js ></script>
<script src="base64.js"></script>
<script src="Detector.js"></script>
<script src="three.min.js"></script>
<script src="TrackballControls.js"></script>
<script src="stats.min.js"></script>
<script src="FileSaver.min.js"></script>
<script src="rawinflate.js"></script>
<script src="rawdeflate.js"></script>
<script>
// copyright (c) 2013 jaanga authors ~ mit license

    var info;
    var renderer, scene, camera, controls, stats;
    var renderer2, scene2, camera2, controls2;
    var reader = new FileReader();
    var FPS = 30;
    var data, palm, fingers = [];
    var data2, palm2, fingers2 = [];
    var recordedFrames = [], recordedFrames2 = [];
    var currentFrame, currentFrame2;
    var isReplaying = false, isRecording = false, frameNum = 0;
    var isReplaying2 = false, isRecording2 = false, frameNum2 = 0;
    var isPaused = false;

    init();
    animate();

    function init() {
        var css, geometry, material, mesh;
        var geometry2, material2, mesh2;

        css = document.body.appendChild( document.createElement('style') );
        css.innerHTML = 'body { font: 600 12pt monospace; overflow: hidden; }' +
            'h1 a {text-decoration: none;}' +
            'input, button { font: 600 12pt monospace; }';

        info = document.body.appendChild( document.createElement( 'div' ) );
        info.innerHTML = info.txt = '<h1 style="display: inline;">Leap Motion Recorder & Replayer</h1>' +
            '<br>Read Data: <input type=file onchange="readFile(this)"  > ' +
            '<button onclick="toggleReplay();" >Toggle Replay</button> - ' +
            '<button onclick="toggleRecording();" >Toggle Recording</button>' +
            '<button onclick="recordedFrames = [];"; >Clear data</button> - ' +
            '<button onclick=saveFile() >Save Data to File</button>' +
            '<br>Read Data2: <input type=file onchange="readFile2(this)"  > ' +
            '<button onclick="toggleReplay2();" >Toggle Replay</button> - ' +
            '<button onclick="toggleRecording2();" >Toggle Recording</button>' +
            '<button onclick="recordedFrames2 = [];"; >Clear data</button> - ' +
            '<button onclick=saveFile() >Save Data2 to File</button>' +

        textareaOutput = document.body.appendChild( document.createElement( 'textarea' ) );
        textareaOutput.style.cssText = 'display: block; font-size:small; width: ' +  0.98 * window.innerWidth + 'px; ';
        textareaOutput.rows =  2;
        textareaOutput.value = '';

        stats = new Stats();
        stats.domElement.style.cssText = 'position: absolute; right: 0; top: 0px; zIndex: 100; ';
        document.body.appendChild( stats.domElement );

        renderer = new THREE.WebGLRenderer( { antialias: true }  );
        renderer.setSize( 0.49 * window.innerWidth, window.innerHeight - 120 );
        renderer.domElement.style.cssText = 'outline: 1px solid #000;';
        document.body.appendChild( renderer.domElement );
        scene = new THREE.Scene();

        camera = new THREE.PerspectiveCamera( 40, (0.45 * window.innerWidth) / (window.innerHeight - 150) , 1, 5000 );
        camera.position.set( 0, 500, 500 );
        controls = new THREE.TrackballControls( camera, renderer.domElement );

        geometry = new THREE.AxisHelper( 80 );
        scene.add( geometry );

        geometry = new THREE.PlaneGeometry( 600, 600, 1, 1 );
        geometry.applyMatrix( new THREE.Matrix4().makeRotationX( - Math.PI / 2 ) );
        material = new THREE.MeshBasicMaterial( {color: Math.random() * 0xffffff, side: THREE.DoubleSide } );
        mesh = new THREE.Mesh( geometry, material );
        mesh.position.set( 0, -100, 0 );
        scene.add( mesh );

        geometry = new THREE.CubeGeometry( 100, 20, 80 );
        material = new THREE.MeshNormalMaterial();
        palm = new THREE.Mesh( geometry, material );
        palm.castShadow = true;
        palm.receiveShadow = true;
        scene.add( palm );

        geometry = new THREE.CubeGeometry( 16, 12, 20 );
        material = new THREE.MeshNormalMaterial();
        for (var j = 0; j < 5; j++) {
            mesh = new THREE.Mesh( geometry, material );
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            scene.add( mesh );
            fingers.push( mesh );
        }

        // Render2

        renderer2 = new THREE.WebGLRenderer( { antialias: true }  );
        renderer2.setSize( 0.49 * window.innerWidth, window.innerHeight - 120 );
        renderer2.domElement.style.cssText = 'outline: 1px solid #000;';
        document.body.appendChild( renderer2.domElement );
        scene2 = new THREE.Scene();

        camera2 = new THREE.PerspectiveCamera( 40, (0.45 * window.innerWidth) / (window.innerHeight - 150) , 1, 5000 );
        camera2.position.set( 0, 500, 500 );
        controls2 = new THREE.TrackballControls( camera2, renderer2.domElement );

        geometry2 = new THREE.AxisHelper( 80 );
        scene2.add( geometry2 );

        geometry2 = new THREE.PlaneGeometry( 600, 600, 1, 1 );
        geometry2.applyMatrix( new THREE.Matrix4().makeRotationX( - Math.PI / 2 ) );
        material2 = new THREE.MeshBasicMaterial( {color: Math.random() * 0xffffff, side: THREE.DoubleSide } );
        mesh2 = new THREE.Mesh( geometry2, material2 );
        mesh2.position.set( 0, -100, 0 );
        scene2.add( mesh2 );

        geometry2 = new THREE.CubeGeometry( 100, 20, 80 );
        material2 = new THREE.MeshNormalMaterial();
        palm2 = new THREE.Mesh( geometry2, material2 );
        palm2.castShadow = true;
        palm2.receiveShadow = true;
        scene2.add( palm2 );

        geometry2 = new THREE.CubeGeometry( 16, 12, 20 );
        material2 = new THREE.MeshNormalMaterial();
        for (var j = 0; j < 5; j++) {
            mesh2 = new THREE.Mesh( geometry2, material2 );
            mesh2.castShadow = true;
            mesh2.receiveShadow = true;
            scene2.add( mesh2 );
            fingers2.push( mesh2 );
        }
    }

    function saveFile() {
        var out = Base64.toBase64(RawDeflate.deflate(Base64.utob(JSON.stringify(recordedFrames))));
        var blob = new Blob( [ out ] , {type: "text/plain;charset=utf-8"} );
        saveAs(blob, 'leapmotion.data');
    }

    function readFile(that){
        if ( that.files && that.files[0]){
            var reader = new FileReader();
            reader.onload = function (e) {
                recordedFrames = JSON.parse(Base64.btou(RawDeflate.inflate(Base64.fromBase64(e.target.result))));
            };
            reader.readAsText(that.files[0]);
        }
    }

    Leap.loop( function( frame ) {
        if (!isPaused) {
            currentFrame = tr(frame);
        }
    });

    setInterval(playFrame, 1/FPS);

    function playFrame() {
        if (!currentFrame) {
            return;
        }
        if (isReplaying) {
            playLoop(currentFrame, palm2, fingers2);
            playLoop(recordedFrames[frameNum], palm, fingers);
            if (!isPaused) {
                frameNum++;
            }
            if (frameNum >= recordedFrames.length) {
                toggleReplay();
            }
            return;
        }
        if (isRecording) {
            recordedFrames.push(tr(currentFrame));
        }
        playLoop(currentFrame, palm, fingers);
        playLoop(currentFrame, palm2, fingers2);
    }

    function tr(frame) {
        // return {"hands":frame.data.hands, "pointables":frame.data.pointables};
        tr_frame = {
            "hands": [],
            "pointables": []
        };
        var handDir = v(0,0,-1);
        if (frame.hands.length > 0) {
            var d = frame.hands[0].direction;
            handDir = vv(d);
        }
        for (var i = 0; i < frame.hands.length; i++) {
            tr_frame.hands.push({
                'stabilizedPalmPosition':normVec(frame.hands[0].stabilizedPalmPosition, handDir),
                'palmNormal':normVec(frame.hands[0].palmNormal, handDir)
            });
        }
        for (var i = 0; i < frame.pointables.length; i++) {
            tr_frame.pointables.push({
                'direction':normVec(frame.pointables[i].direction, handDir),
                'stabilizedTipPosition':normVec(frame.pointables[i].stabilizedTipPosition, handDir),
                'length':frame.pointables[i].length
            });
        }
        tr_frame.pointables.sort(sortPointable);
        return tr_frame;
    }

    function toggleReplay() {
        if (recordedFrames.length == 0) {
            textareaOutput.value = 'No recorded frames.';
            return;
        }
        frameNum = 0;
        isReplaying = !isReplaying;
        textareaOutput.value = isReplaying ? 'Replaying...':'';
    }

    function toggleReplay2() {
        if (recordedFrames2.length == 0) {
            textareaOutput.value = 'No recorded frames.';
            return;
        }
        frameNum = 0;
        isReplaying2 = !isReplaying2;
        textareaOutput.value = isReplaying2 ? 'Replaying 2...':'';
    }

    // Press spacebar to toggle pause
    window.onkeypress = function(e) {
        if (e.charCode == 32) {
            if (!isRecording && !isRecording2) {
                isPaused = !isPaused;
                textareaOutput.value = isPaused ? 'Paused':'';
            }
        }
    };

    function toggleRecording() {
        isRecording = !isRecording;
        textareaOutput.value = isRecording ? 'Recording...':'';
        if (isRecording) {
            recordedFrames = [];
        }
    }

    function normVec(vec, handDir) {
        // Rotate a vector to eliminate the effect of different hand direction
        // Hand direction will be fixed at (0,0,-1)
        var vec3 = vv(vec);
        var n = v(0,0,-1);
        var a = new THREE.Vector3();
        a.crossVectors(handDir, n); // a = handDir x n
        a.normalize();
        if (a.length() > 0) {
            vec3.applyAxisAngle(a, handDir.angleTo(n));
        }
        return [vec3.x,vec3.y,vec3.z];
    }

    function playLoop( frame, palm, fingers ) {
        var hand, direction, len, finger, pointable;
        if ( frame.hands.length > 0) {
            hand = frame.hands[0];
            palm.position.set( hand.stabilizedPalmPosition[0], hand.stabilizedPalmPosition[1], hand.stabilizedPalmPosition[2] );
            direction = v(0,0,-1);
            palm.lookAt( direction.add( palm.position ) );
            roll = Math.atan2( hand.palmNormal[0], hand.palmNormal[1] );
            palm.rotation.z = roll;
            palm.visible = true;
        } else {
            palm.visible = false;
        }

        len = frame.pointables.length
        if ( len > 0) {
            palm.hasFingers = true;
            for (var i = 0; i < 5; i++) {
                finger = fingers[i];
                if ( i < len ) {
                    pointable = frame.pointables[i];
                    finger.position.set( pointable.stabilizedTipPosition[0], pointable.stabilizedTipPosition[1], pointable.stabilizedTipPosition[2] );
                    direction = vv(pointable.direction);  // best so far
                    finger.lookAt( direction.add( finger.position ) );
                    finger.scale.z = 0.05 * pointable.length;
                    finger.visible = true;
                } else {
                    fingers[i].visible = false;
                }
            }
        } else if ( palm.hasFingers ) {
            for (var i = 0; i < 5; i++) {
                fingers[i].visible = false;
            }
            palm.hasFingers = false;
        }
    }

    function distance(frame1, frame2) {
        dist = 0;
        for (var i = 0; i < 5; i++) {
            dist += Math.sqrt(1-sq(vv(frame1.pointables[i].direction).dot(vv(frame2.pointables[i].direction))));
        }
        return dist/5;
    }

    function similarity(frame1, frame2) {
        dist = 0;
        for (var i = 0; i < 5; i++) {
            dist += vv(frame1.pointables[i].direction).dot(vv(frame2.pointables[i].direction));
        }
        return dist/5;
    }

    function sortPointable(p1, p2) {
        return p1.stabilizedTipPosition[0] - p2.stabilizedTipPosition[0];
    }

    function DTW() {}

    function sq(x) {
        return x*x;
    }

    function animate() {
        requestAnimationFrame( animate );
        controls.update();
        renderer.render( scene, camera );
        controls2.update();
        renderer2.render( scene2, camera2 );
        stats.update();
    }

    function v( x, y, z ){ return new THREE.Vector3( x, y, z ); }
    function vv(v) {
        return new THREE.Vector3(v[0], v[1], v[2]);
    }
</script>
</body>
</html>
